package com.synopsys.homework;

import java.io.IOException;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.tree.ParseTree;
import org.slf4j.LoggerFactory;

import antlr4.CalcGrammarLexer;
import antlr4.CalcGrammarParser;
import ch.qos.logback.classic.Logger;

import com.synopsys.homework.exception.CalculatorException;
import com.synopsys.homework.utils.CliOptionUtil;

/**
 * Main class that takes expression to be evaluated and optional logging level
 * as command line arguments USAGE: java -jar integer-calculator-program-0.0.1-SNAPSHOT-jar-with-dependencies.jar <INPUT-EXPRESSION> <OPTIONAL-LOGGING-LEVEL>";
 */
public class AppCalculator {
	private static final Logger LOG = (Logger) LoggerFactory.getLogger(AppCalculator.class);

	public static void main(String[] args) throws IOException, CalculatorException, NullPointerException {
		if (args.length == 0) {
			String message = "Proper usage: java -jar integer-calculator-program-0.0.1-SNAPSHOT-jar-with-dependencies.jar <INPUT-EXPRESSION> <OPTIONAL-LOGGING-LEVEL>";
			LOG.warn(message);
			throw new CalculatorException(message);
		}

		if (args.length > 1) {
			String logLevel = args[1];
			if (CliOptionUtil.isSupported(logLevel)) { // Checking if the logging level is supported
				CliOptionUtil.setAppLogLevel(logLevel);
				LOG.debug("Log Level set to: {}", logLevel);
			} else {
				String message = "Supported Log Levels are: INFO, OFF, WARN|WARNING, DEBUG|FINE and ERROR|SEVERE, please re-run with supported logging levels!";
				LOG.warn(message);
				throw new CalculatorException(message);
			}
		}

		String expression = args[0];
		LOG.debug("Inside main, expression to be evaluated: {}", expression);

		if (expression.length() == 0 || expression == null) {
			String msg = "Expression to be evaluated cannot be empty/null";
			LOG.error(msg);
			throw new NullPointerException(msg);
		}

		Integer result = null;

		try {
			result = evaluate(expression);
			if (result == null) {
				String message = "Expression couldn't be evaluated to an integer result";
				LOG.error(message);
				throw new NullPointerException(message);
			}
			System.out.println(result);
		} catch (CalculatorException ex) {
			String message = "Exception while parsing, expression couldn't be evaluated";
			LOG.error(message);
		} catch (NullPointerException ex) {
			String message = "Invalid expression, couldn't be evaluated";
			LOG.error(message);
		}
	}

	/**
	 * This method takes the expression to be evaluated and returns the integer
	 * result
	 * 
	 * @param expression
	 *            : expression to be evaluated
	 * @return Integer result
	 * @throws NullPointerException
	 * @throws CalculatorException
	 */
	protected static Integer evaluate(String expression) throws CalculatorException {
		LOG.debug("Inside evaluate(), expression to be evaluated: {}", expression);

		/*
		 * An input string expression is fed to Lexer generated by antl4 using
		 * grammar file As per the parse rule defined in the grammar file,
		 * Parser can recognize the string with the help of tokens tagged by the
		 * lexer By extending the generated visitor class, we can visit entry
		 * method defined by the parser rule to fetch result.
		 */
		ANTLRInputStream input = new ANTLRInputStream(expression);
		CalcGrammarLexer lexer = new CalcGrammarLexer(input); //
		CommonTokenStream tokens = new CommonTokenStream(lexer);
		CalcGrammarParser parser = new CalcGrammarParser(tokens);
		ParseTree tree;
		Integer result = null;

		try {
			tree = parser.prog();
			EvaluateExpressionVisitor eval = new EvaluateExpressionVisitor();
			result = eval.visit(tree);
		} catch (RecognitionException r) {
			String msg = "An exception caught while parsing or evaluating!";
			LOG.error(msg);
			throw new CalculatorException(msg, r);
		}

		return result;
	}
}
